\section{ОПИСАНИЕ ПОСЛЕДОВАТЕЛЬНОГО АЛГОРИТМА РЕШЕНИЯ ЗАДАЧИ}

Сперва массивы $\vb{A}$ и $\vb{B}$ размера $n$ заполняются случайными числами с плавающей точкой (тип \texttt{float}), имеющими значение от 0 до 1. Отвечающий инициализации массивов код представлен в Листинге \ref{listing:arrayInit}.
\begin{lstlisting}[style=CStyle, label={listing:arrayInit}, caption={Инициализация массивов $\vb{A}$ и $\vb{B}$ размера $n$ случайными числами с плавающей точкой (тип \texttt{float}), имеющими значение от 0 до 1.}]
	// ...
	// Arrays declaration
	float *hostA, *hostB;
	// Arrays allocation
	hostA = (float*)malloc(n*sizeof(float));
	hostB = (float*)malloc(n*sizeof(float));
	// Arrays initialization
	for (int i=0; i<n; i++){
		hostA[i] = (float)rand()/(float)(RAND_MAX);
		hostB[i] = (float)rand()/(float)(RAND_MAX);
	}
	// ...
\end{lstlisting}

Далее необходимо отсортировать элементы массивов в порядке убывания. Для этого была выбрана \textbf{сортировка пузырьком}. Последовательная версия данного алгоритма представлена в Листинге \ref{listing:bubbleSortSerial}. 
Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется перестановка элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу очередной наименьший элемент массива ставится на своё место в конце массива рядом с предыдущим «наименьшим элементом», а наибольший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма). 
\begin{lstlisting}[style=CStyle, label={listing:bubbleSortSerial}, caption={Последовательная версия сортировки пузырьком.}]
/** Sorts hostArray with the help of the Bubble sorting (CUDA is not used)
 *	@param hostArray Sorted array
 *	@param n Size of the sorted array
 */
void bubbleSortCPU(float *hostArray, int n){
	float temp; // Temporary variable
	for (int i = 0; i < n; i++){
    for (int j = 0; j < n-i-1; j++) {
      if (hostArray[j]<hostArray[j+1]){
        temp = hostArray[j];
        hostArray[j] = hostArray[j+1];
        hostArray[j+1] = temp;
      }
    }
  }
}
\end{lstlisting}

После сортировки элементов массива выполняется скалярное произведение двух массивов --- вычисляется сумма произведений элементов двух массивов с одинаковыми индексами. Последовательная реализация скалярного произведения представлена в Листинге \ref{listing:dotProdSerial}.
\begin{lstlisting}[style=CStyle, label={listing:dotProdSerial}, caption={Последовательная версия скалярного произведения.}]
/** Computes dot product (CUDA is not used)
 *	@param hostA First array
 *	@param hostB Second array
 *	@param n Size of arrays
 */
float dotProdCPU(float const *hostA, float const *hostB, int n){
	float res = 0;
	for (int i = 0; i < n; i++) {
		res += hostA[i] * hostB[i];
	}
	return res;
}
\end{lstlisting}